rough
================================================================================
Add a comment to your code, run the macro command and rough generates code.

The macros are  not removed from the source code and can easly be updated.

Currently there are macros to:
 - generate get methods
 - generate set methods
 - emulate traits in PHP 5.3

Macro Syntax
--------------------------------------------------------------------------------

    #@<macroname> <arg1> <arg2> .... <argN>#
    #@Ã¤
    
 - Macros are line comments. 
 - There must not be anything but whitespace before the first '#'.

I will use the get macro as an example.

###basic syntax

    protected $name;
    #@get public name#
    #@#
    
The first line starts the macro- The second marks the end of the macro.
All code generated by the macro will go between those two lines. Any manual
changes to the generated code are lost when the macro is executed.

###shorthand notation
When you first define a macro you can use a shorthand notation:

    protected $name;
    #@get public name@#
    
###arguments
arguments are seperated by whitespace:

    #@get public name string@#

The simplest form of argument is a *single word* in the example above the 'get'
macro will be called with the two arguments 'name' and 'string'.

If an argument contains whitespace surround it with double quotes to mark it
as a *litteral*:

    @get "public final" name string@#

In the example above the 'get' macro will be called with the two arguments 
'public final' and 'string'.

Some macros support passing a *array* as an arument:
    
    protected
        $name,
        $email;
        
    #@get [name email] string@#
    
In the example above the 'get' macro will be called with the two arguments 
array('name','email') and 'string'.
The members of the array are seperated the same way normal arguments are so you 
can place an literal in an array:

    protected
        $name,
        $email;
        
    #@get public [name email "invalid property name"] string@#
    
Nested arrays are *not* supported.

Running Macros
--------------------------------------------------------------------------------

Running the macros requires two steps:

 - add build settings to your composer.json
 - tun the rough commandline tool
 
###The Build File

Before running the rough tool you have to add some information to your 
composer.json.

    "extra":{
            "dalia-it":{
                "rough":{
                    "build":{
                        "source": "src/",
                        "output": "src/"
                    }
                }
            }
        }
    }

The *source* option tells rough where to look for files.

The *output* option tells rough where to write the results.

Once you have everything set up, run the rough commandline tool:

    php vendor/bin/rough macros

This will look for a composer.json in the current work directory.
If you want to use a differnt file you can pass it as an parameter.

    php vendor/bin/rough macros vendor/foo/foo/build.json

Default Macrosos 
--------------------------------------------------------------------------------
- [Acess](blob/master/src/daliaIT/rough/macro/AccessMacro.php)
- [Get](blob/master/src/daliaIT/rough/macro/AccessMacro.php)
- [import](blob/master/src/daliaIT/rough/macro/AccessMacro.php)
- [set](blob/master/src/daliaIT/rough/macro/AccessMacro.php)
- [trait](blob/master/src/daliaIT/rough/macro/AccessMacro.php)

imports and trait
--------------------------------------------------------------------------------    
    
Traits are a great PHP 5.4 feature. In PHP 5.3 you can use rough to emulate some
(but not all) features of traits.

The import macro simply copies the body of one class into another.

The advantages over a manual copy and paste: 
 - The import macro will update the code if you change it.
 - If you build your project in PHP >=5.4.0 the macros will create normal traits

Since this sollution does *not* support inheritance or namespaces you should
only import classes which are designed to be used this way (pseudo traits).

 - Pseudo traits are final.
 - Psudo must always use fully qualified class names.

Define a pseudo trait:

    namespace vendor\product;
    #@trait Unique@#
    {
        protected $uniqueId;
        
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
    }
    
Use the pseudo trait:

    namespace vendor\product;
    class User:
    {
        #@import vendor\product\Unique@#
    }
    
###Results:

####PHP < 5.4.0

The trait:

    namespace vendor\product;
    #@trait#
    final class Unique
    #@#
    {
        protected $uniqueId;
        
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
    }
    
The using class:

    namespace vendor\product;
    class User:
    {
        #@import vendor\product\Unique@#
        protected $uniqueId;
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
        #@#
    }
    

####PHP >= 5.4.0

The trait:

    namespace vendor\product;
    #@trait#
    trait Unique
    #@#
    {
        protected $uniqueId;
        
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
    }
    
The using class:

    namespace vendor\product;
    class User:
    {
        #@import vendor\product\Unique@#
        use \vendor\product\Unique;
        #@#
    }