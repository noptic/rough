rough
================================================================================
Compiles embedded macros into PHP code.
Add a comment into your code, run the macro command and rough generates code.

The macro markup is not removed so if the macro are updated so the generated 
code is updated too.

Currently there are macros to:
 - generate get methods
 - generate set methods
 - emulate traits in PHP 5.3

Macro Syntax
--------------------------------------------------------------------------------

    #@macroname arg1 arg2 argN@#
    #@Ã¤
    
Macros are line comments. There must not be anything but whitespace before the 
first '#'.

I will use the get macro as an example.

###basic syntax

    protected $name;
    #@get name#
    #@#
    
The first line starts the macro and the second marks the end of the macro.
All code generated by the macro will go between those two lines. Any manual
changes to the generated code will be overriden when the macro is executed.

###shorthand notation
When you first define a macro you can use a shorthand notation:

    protected $name;
    #@get name@#
    
###arguments
arguments are seperated by Whitesoace:

    #@get name string@#

The simplest form of argument is a *single word* in the example above the 'get'
macro will be called with the two arguments 'name' and 'string'.

If a argument contains a whitespaces surround it with double quotes to mark it
as a *litteral*:

    @get "invalid property name" string@#

In the example above the 'get' macro will be called with the two arguments 
'invalid property name' and 'string'.

Some macros support passing a *array* as an arument:
    
    protected
        $name,
        $email;
        
    #@get [name email] string@#
    
In the example above the 'get' macro will be called with the two arguments 
array('name','email') and 'string'.
The members of the array are seperated the same way normal arguments are so you 
can place an literal in an array:

    protected
        $name,
        $email;
        
    #@get [name email "invalid property name"] string@#
    
Nested arrays are *not* supported.

Running Macros
--------------------------------------------------------------------------------

Running the macros requires two steps:

 - add build settings to your composer.json
 - tun the rough commandline tool
 - 
 
###The Build File

Before running the rough tool you have to add some information to your 
composer.json.

    "extra":{
            "dalia-it":{
                "rough":{
                    "build":{
                        "source": "src/",
                        "output": "src/"
                    }
                }
            }
        }
    }

The *source* option tells rough where to look for files.

The *output* option tells rough where to write the results.

If source and output point to the same directory files in source will be
replaced.

Once you have everything set up, run the rough commandline tool:

    php vendor/bin/rough macros

This will look for a composer.json in the current work directory.
If you want a differnt file you can pass it as an parameter.

    php vendor/bin/rough macros vendor/foo/foo/build.json

Default Macrosos 
--------------------------------------------------------------------------------
###Get

###Set

###access

###import and trait
Traits are a great PHP 5.4 feature. In PHP 5.3 you can use rough to emulate some
(but not all) features of traits.

The import macros simply copies the body of one class into another.

The advantages over a manual copy and paste: 
 - The import macro will update the code if you change it.
 - If you build your project in PHP >=5.4.0 the macros will create normal traits

Since this sollution does *not* support inheritance or namespaces you should
only import classes which are designed to be used this way (pseudo traits).

 - Pseudo traits are final.
 - Psudo must always use fully qualified class names.

Define a pseudo trait:

    namespace vendor\product;
    #@trait Unique@#
    {
        protected $uniqueId;
        
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
    }
    
Use the pseudo trait:

    namespace vendor\product;
    class User:
    {
        #@import vendor\product\Unique@#
    }
    
####Results:

#####PHP < 5.4.0

The trait:

    namespace vendor\product;
    #@trait#
    final class Unique
    #@#
    {
        protected $uniqueId;
        
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
    }
    
The using class:

    namespace vendor\product;
    class User:
    {
        #@import vendor\product\Unique@#
        protected $uniqueId;
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
        #@#
    }
    

#####PHP >= 5.4.0

The trait:

    namespace vendor\product;
    #@trait#
    trait Unique
    #@#
    {
        protected $uniqueId;
        
        public function getUniqueId(){...}
        public function setUniqueId(\vendor\product\UniqueId $value){...}
    }
    
The using class:

    namespace vendor\product;
    class User:
    {
        #@import vendor\product\Unique@#
        use \vendor\product\Unique;
        #@#
    }